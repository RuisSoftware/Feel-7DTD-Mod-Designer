// Assets/Editor/BetterStacksToolWindow.cs
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text;
using System.Text.RegularExpressions;
using System.Xml.Linq;
using UnityEditor;
using UnityEngine;
using Microsoft.Win32; // For Steam registry lookup

public class BetterStacksToolWindow : EditorWindow
{
    // === Defaults ===
    private string modsBasePath =
        Path.Combine(
            Environment.GetFolderPath(Environment.SpecialFolder.ApplicationData),
            "7DaysToDie", "Mods");

    private string configBasePath =
        Path.Combine("D:\\", "Programs", "Steam", "steamapps", "common",
                     "7 Days To Die", "Data", "Config");

    private string modNameBase = "feel-betterstacks";

    // Action: either Multiply or Set
    private enum StackAction { Multiply, Set }
    private StackAction selectedAction = StackAction.Multiply;

    // Types
    private bool typeItem = true;
    private bool typeBlock = true;

    // Filters
    private bool skipDefaultOne = true; // Skip elements whose original Stacknumber == 1

    // CSV inputs
    private string numbersCsv = "100,200,1000,10000,25000,30000,50000";
    private string exclusionsCsv = "";

    private Vector2 _scroll;

    // UI
    private bool showHowItWorks = true;

    // --- ModInfo & Readme (editable in the editor) ---
    private bool modInfoFoldout = true;
    private bool modInfoUseGeneratedName = true; // when true, Name/DisplayName are set to the generated mod folder name
    private string modInfoName = "";             // only used when modInfoUseGeneratedName == false
    private string modInfoDisplayName = "";      // only used when modInfoUseGeneratedName == false
    private string modInfoAuthor = "You";
    private string modInfoVersion = "1.0.0";
    private string modInfoWebsite = "";
    private string modInfoDescription = "Created with Better Stacks Generator";

    private string readmeMarkdown =
@"# Better Stacks
This mod adjusts stack sizes using XPath patches generated by the Better Stacks tool.
- Original game files are not modified.
- You can safely remove this mod from the Mods folder to revert the changes.";

    // AUTO-DETECT flag
    private bool autoDetectTried = false;

    [MenuItem("Tools/Feel 7DTD/Better Stacks Generator")]
    public static void ShowWindow()
    {
        var win = GetWindow<BetterStacksToolWindow>("Better Stacks");
        win.minSize = new Vector2(700, 520);
    }

    private void OnGUI()
    {
        TryAutoDetect7DTDPathsOnce();  // AUTO-DETECT, once per open

        _scroll = EditorGUILayout.BeginScrollView(_scroll);

        EditorGUILayout.LabelField("Better Stacks Generator", EditorStyles.boldLabel);
        EditorGUILayout.Space(4);

        // --- How it works ---
        showHowItWorks = EditorGUILayout.Foldout(showHowItWorks, "How this tool works");
        if (showHowItWorks)
        {
            EditorGUILayout.HelpBox(
@"• Pick your game Config folder (contains items.xml / blocks.xml) and your Mods output folder.
• Choose an Action:
   - Multiply: multiplies each found Stacknumber by the chosen number(s).
   - Set: sets Stacknumber directly to the chosen number(s).
• Choose which types to process (items, blocks).
• Enter one or more numbers (comma-separated).
• Optionally:
   - Exclusions: skip any entries whose name contains any of these substrings.
   - Skip default-1 stacks: when enabled, entries with original Stacknumber = 1 are ignored.
• Click 'Generate Better Stack Mods'. The tool creates separate, patch-only mods in the Mods folder.
• Each mod contains a Config file with <set xpath=""...""> patches; the original game files are not modified.
• You can also edit ModInfo (Name/DisplayName/Author/Version/Website/Description) and the readme here. The tool writes a ModInfo.xml and a readme.md into each generated mod.",
            MessageType.Info);
        }

        EditorGUILayout.Space(6);

        // --- Paths ---
        EditorGUILayout.LabelField("Paths", EditorStyles.boldLabel);

        EditorGUILayout.BeginHorizontal();
        EditorGUILayout.LabelField("Mods base path", GUILayout.Width(140));
        modsBasePath = EditorGUILayout.TextField(modsBasePath);
        if (GUILayout.Button("Browse", GUILayout.Width(80)))
        {
            string sel = EditorUtility.OpenFolderPanel("Select Mods base folder", modsBasePath, "");
            if (!string.IsNullOrEmpty(sel))
                modsBasePath = sel;
        }
        EditorGUILayout.EndHorizontal();

        EditorGUILayout.BeginHorizontal();
        EditorGUILayout.LabelField("Config base path", GUILayout.Width(140));
        configBasePath = EditorGUILayout.TextField(configBasePath);
        if (GUILayout.Button("Browse", GUILayout.Width(80)))
        {
            string sel = EditorUtility.OpenFolderPanel("Select 7DTD Data/Config folder", configBasePath, "");
            if (!string.IsNullOrEmpty(sel))
                configBasePath = sel;
        }
        EditorGUILayout.EndHorizontal();

        // Manual auto-detect trigger
        EditorGUILayout.BeginHorizontal();
        GUILayout.FlexibleSpace();
        if (GUILayout.Button("Auto-detect 7DTD", GUILayout.Width(160)))
        {
            TryAutoDetect7DTDPaths(showDialog: true);
        }
        EditorGUILayout.EndHorizontal();

        EditorGUILayout.Space(10);

        // --- Mod naming ---
        EditorGUILayout.LabelField("Mod naming", EditorStyles.boldLabel);
        modNameBase = EditorGUILayout.TextField("Base mod name", modNameBase);

        EditorGUILayout.Space(8);

        // --- Action ---
        EditorGUILayout.LabelField("Action", EditorStyles.boldLabel);
        selectedAction = (StackAction)EditorGUILayout.EnumPopup("Mode", selectedAction);

        EditorGUILayout.Space(8);

        // --- Types ---
        EditorGUILayout.LabelField("Types", EditorStyles.boldLabel);
        EditorGUILayout.BeginHorizontal();
        typeItem = EditorGUILayout.ToggleLeft("item", typeItem, GUILayout.Width(120));
        typeBlock = EditorGUILayout.ToggleLeft("block", typeBlock, GUILayout.Width(120));
        EditorGUILayout.EndHorizontal();

        EditorGUILayout.Space(8);

        // --- Filters ---
        EditorGUILayout.LabelField("Filters", EditorStyles.boldLabel);
        skipDefaultOne = EditorGUILayout.ToggleLeft("Skip entries with original Stacknumber = 1 (recommended)", skipDefaultOne);
        EditorGUILayout.HelpBox(
            "When enabled, any item/block whose original Stacknumber is exactly 1 will be ignored and no <set> patch is generated for it.",
            MessageType.None);

        EditorGUILayout.Space(12);

        // --- Numbers ---
        EditorGUILayout.LabelField("Stack numbers", EditorStyles.boldLabel);
        EditorGUILayout.HelpBox(
            "Comma-separated integers. Example: 100,200,1000,10000,25000,30000,50000",
            MessageType.Info);
        numbersCsv = EditorGUILayout.TextField("Numbers", numbersCsv);

        EditorGUILayout.Space(12);

        // --- Exclusions ---
        EditorGUILayout.LabelField("Exclusions", EditorStyles.boldLabel);
        EditorGUILayout.HelpBox(
            "Comma-separated substrings. If an entry name contains any of these substrings, it will be skipped. Case-insensitive.",
            MessageType.Info);
        exclusionsCsv = EditorGUILayout.TextField("Exclude names", exclusionsCsv);

        EditorGUILayout.Space(16);

        // --- ModInfo & Readme ---
        modInfoFoldout = EditorGUILayout.Foldout(modInfoFoldout, "ModInfo & Readme");
        if (modInfoFoldout)
        {
            EditorGUILayout.BeginVertical("box");
            modInfoUseGeneratedName = EditorGUILayout.ToggleLeft("Use generated name for Name & DisplayName", modInfoUseGeneratedName);
            using (new EditorGUI.DisabledGroupScope(modInfoUseGeneratedName))
            {
                modInfoName = EditorGUILayout.TextField("Name", modInfoName);
                modInfoDisplayName = EditorGUILayout.TextField("DisplayName", modInfoDisplayName);
            }
            modInfoAuthor = EditorGUILayout.TextField("Author", modInfoAuthor);
            modInfoVersion = EditorGUILayout.TextField("Version", modInfoVersion);
            modInfoWebsite = EditorGUILayout.TextField("Website", modInfoWebsite);
            EditorGUILayout.LabelField("Description");
            modInfoDescription = EditorGUILayout.TextArea(modInfoDescription, GUILayout.MinHeight(48));

            EditorGUILayout.Space(6);
            EditorGUILayout.LabelField("readme.md (Markdown)");
            readmeMarkdown = EditorGUILayout.TextArea(readmeMarkdown, GUILayout.MinHeight(120));
            EditorGUILayout.EndVertical();
        }

        EditorGUILayout.Space(16);

        using (new EditorGUI.DisabledGroupScope(!CanRun()))
        {
            if (GUILayout.Button("Generate Better Stack Mods", GUILayout.Height(32)))
            {
                RunGenerator();
            }
        }

        if (!CanRun())
        {
            EditorGUILayout.HelpBox(
                "Please set a valid Mods path and Config path, and select at least one type (item/block).",
                MessageType.Warning);
        }

        EditorGUILayout.EndScrollView();
    }

    private bool CanRun()
    {
        if (string.IsNullOrEmpty(modsBasePath) || string.IsNullOrEmpty(configBasePath))
            return false;
        if (!Directory.Exists(configBasePath))
            return false;
        if (!typeItem && !typeBlock)
            return false;
        return true;
    }

    private void RunGenerator()
    {
        string action = selectedAction == StackAction.Multiply ? "multiply" : "set";

        var types = new List<string>();
        if (typeItem) types.Add("item");
        if (typeBlock) types.Add("block");

        var numbers = ParseIntList(numbersCsv);
        if (numbers.Count == 0)
        {
            EditorUtility.DisplayDialog("No numbers", "No valid integers found in 'Numbers'.", "OK");
            return;
        }

        var exclusions = ParseStringList(exclusionsCsv);
        if (exclusions.Count == 1 && string.IsNullOrWhiteSpace(exclusions[0]))
            exclusions.Clear();

        try
        {
            int totalSteps = numbers.Count * types.Count;
            int step = 0;

            foreach (var num in numbers)
            {
                foreach (var type in types)
                {
                    float progress = (float)step / Mathf.Max(1, totalSteps);
                    EditorUtility.DisplayProgressBar(
                        "Generating Better Stacks",
                        $"{action} {num} on {type}s",
                        progress);

                    CreateModFolders(action, num, type, modNameBase,
                                     modsBasePath, configBasePath,
                                     exclusions);
                    step++;
                }
            }

            EditorUtility.ClearProgressBar();
            EditorUtility.DisplayDialog("Done", "All operations completed successfully!\nCheck the output in the Mods directory.", "OK");
        }
        catch (Exception ex)
        {
            EditorUtility.ClearProgressBar();
            Debug.LogError("[BetterStacks] Error: " + ex);
            EditorUtility.DisplayDialog("Error", ex.Message, "OK");
        }
    }

    // === CORE LOGIC ===

    private void CreateModFolders(
        string action,
        int number,
        string type,
        string modNameBase,
        string modsBasePath,
        string configBasePath,
        List<string> exclusions)
    {
        string modName = $"{modNameBase}_{action}_{number}";
        string modPath = Path.Combine(modsBasePath, modName);
        string configPath = Path.Combine(modPath, "Config");
        Directory.CreateDirectory(configPath);

        string originalFilePath = Path.Combine(configBasePath, $"{type}s.xml");
        if (!File.Exists(originalFilePath))
        {
            Debug.LogWarning($"[{modName}] Source file not found: {originalFilePath}");
            return;
        }

        XDocument xdoc = XDocument.Load(originalFilePath);
        XElement root = xdoc.Root;
        if (root == null)
        {
            Debug.LogWarning($"[{modName}] Root missing in {originalFilePath}");
            return;
        }

        string outFile = Path.Combine(configPath, $"{type}s.xml");
        int writeCount = 0;

        using (var writer = new StreamWriter(outFile, false, new UTF8Encoding(encoderShouldEmitUTF8Identifier: false)))
        {
            writer.WriteLine("<?xml version=\"1.0\" encoding=\"UTF-8\"?>");
            writer.WriteLine("<configs>");

            var elements = root
                .Descendants(type)
                .Where(e => e.Attribute("name") != null);

            foreach (var element in elements)
            {
                string elementName = (string)element.Attribute("name") ?? "";

                // Name exclusions
                if (exclusions.Any(excl =>
                        !string.IsNullOrEmpty(excl) &&
                        elementName.IndexOf(excl, StringComparison.OrdinalIgnoreCase) >= 0))
                {
                    continue;
                }

                // Skip entries that have ModSlots > 0 (optional behavior retained)
                var modSlotsEffect = element
                    .Descendants("passive_effect")
                    .FirstOrDefault(pe => (string)pe.Attribute("name") == "ModSlots");

                if (modSlotsEffect != null)
                {
                    string value = (string)modSlotsEffect.Attribute("value") ?? "0";
                    if (HasModSlots(value))
                    {
                        continue;
                    }
                }

                // Locate Stacknumber property
                var stackProp = element
                    .Descendants("property")
                    .FirstOrDefault(p => (string)p.Attribute("name") == "Stacknumber");

                if (stackProp == null)
                    continue;

                string stackVal = (string)stackProp.Attribute("value") ?? "";
                if (!Regex.IsMatch(stackVal, @"^\d+$"))
                    continue;

                int oldValue = int.Parse(stackVal);

                // Skip default=1 stacks if enabled
                if (skipDefaultOne && oldValue == 1)
                    continue;

                int newValue = action == "multiply" ? oldValue * number : number;

                string safeName = EscapeForXPathName(elementName);
                string xpath = $"/{type}s/{type}[@name='{safeName}']/property[@name='Stacknumber']/@value";

                writer.Write("   <set xpath=\"");
                writer.Write(xpath);
                writer.Write("\">");
                writer.Write(newValue);
                writer.WriteLine("</set>");

                writeCount++;
            }

            writer.WriteLine("</configs>");
        }

        if (writeCount == 0)
        {
            Debug.Log($"[BetterStacks][{modName}] No patches produced (filters may have excluded all candidates).");
        }

        // --- Write ModInfo.xml ---
        WriteModInfo(modPath, modName);

        // --- Write readme.md ---
        WriteReadme(modPath);

        Debug.Log($"[BetterStacks] Generated mod: {modName} ({writeCount} patch(es))");
    }

    private void WriteModInfo(string modPath, string generatedModName)
    {
        string nameVal = modInfoUseGeneratedName
            ? generatedModName
            : string.IsNullOrWhiteSpace(modInfoName) ? generatedModName : modInfoName;

        string displayVal = modInfoUseGeneratedName
            ? generatedModName
            : string.IsNullOrWhiteSpace(modInfoDisplayName) ? nameVal : modInfoDisplayName;

        string xml =
$@"<?xml version=""1.0"" encoding=""UTF-8""?>
<xml><ModInfo>
  <Name value=""{EscapeXml(nameVal)}""/>
  <DisplayName value=""{EscapeXml(displayVal)}""/>
  <Description value=""{EscapeXml(modInfoDescription)}"" />
  <Author value=""{EscapeXml(modInfoAuthor)}""/>
  <Version value=""{EscapeXml(modInfoVersion)}""/>
  <Website value=""{EscapeXml(modInfoWebsite)}"" />
</ModInfo></xml>";

        string outPath = Path.Combine(modPath, "ModInfo.xml");
        Directory.CreateDirectory(modPath);
        File.WriteAllText(outPath, xml, new UTF8Encoding(encoderShouldEmitUTF8Identifier: false));
    }

    private void WriteReadme(string modPath)
    {
        string outPath = Path.Combine(modPath, "readme.md");
        Directory.CreateDirectory(modPath);
        File.WriteAllText(outPath, readmeMarkdown ?? "", new UTF8Encoding(encoderShouldEmitUTF8Identifier: false));
    }

    private static string EscapeXml(string s)
    {
        if (string.IsNullOrEmpty(s)) return "";
        return s.Replace("&", "&amp;").Replace("<", "&lt;").Replace(">", "&gt;")
                .Replace("\"", "&quot;").Replace("'", "&apos;");
    }

    // === AUTO-DETECT 7DTD ===

    private void TryAutoDetect7DTDPathsOnce()
    {
        if (autoDetectTried) return;
        autoDetectTried = true;
        TryAutoDetect7DTDPaths(showDialog: false);
    }

    private void TryAutoDetect7DTDPaths(bool showDialog)
    {
        string foundConfig = Find7DTDConfigPath();
        string foundMods = null;

        if (!string.IsNullOrEmpty(foundConfig))
        {
            configBasePath = foundConfig;

            // Try AppData\7DaysToDie\Mods first
            var appDataMods = Path.Combine(
                Environment.GetFolderPath(Environment.SpecialFolder.ApplicationData),
                "7DaysToDie", "Mods");

            if (Directory.Exists(appDataMods))
            {
                foundMods = appDataMods;
            }
            else
            {
                // Otherwise a Mods folder next to the game installation
                var gameDir = Directory.GetParent(Directory.GetParent(foundConfig).FullName)?.FullName; // ...\7 Days To Die
                if (!string.IsNullOrEmpty(gameDir))
                {
                    var modsDir = Path.Combine(gameDir, "Mods");
                    if (Directory.Exists(modsDir))
                        foundMods = modsDir;
                }
            }
        }

        if (!string.IsNullOrEmpty(foundMods))
            modsBasePath = foundMods;

        if (showDialog)
        {
            if (!string.IsNullOrEmpty(foundConfig))
            {
                EditorUtility.DisplayDialog(
                    "7 Days to Die found",
                    $"Config path:\n{foundConfig}\n\nMods path:\n{modsBasePath}",
                    "OK");
            }
            else
            {
                EditorUtility.DisplayDialog(
                    "7 Days to Die not found automatically",
                    "The installation could not be auto-detected.\n" +
                    "Please fill in the paths manually or use the Browse buttons.",
                    "OK");
            }
        }
    }

    private string Find7DTDConfigPath()
    {
        // 1) Use existing path if it looks valid
        if (!string.IsNullOrEmpty(configBasePath) &&
            Directory.Exists(configBasePath) &&
            File.Exists(Path.Combine(configBasePath, "items.xml")))
        {
            return configBasePath;
        }

        // 2) Via Steam registry
        var candidates = new List<string>();
        string steamPath = GetSteamPathFromRegistry();
        if (!string.IsNullOrEmpty(steamPath))
        {
            var commonDefault = Path.Combine(steamPath, "steamapps", "common");
            if (Directory.Exists(commonDefault))
                candidates.Add(commonDefault);

            // Library folders
            var vdf = Path.Combine(steamPath, "steamapps", "libraryfolders.vdf");
            if (File.Exists(vdf))
            {
                try
                {
                    foreach (var line in File.ReadAllLines(vdf))
                    {
                        var m = Regex.Match(line, "\"path\"\\s*\"([^\"]+)\"");
                        if (m.Success)
                        {
                            var lib = m.Groups[1].Value.Replace("\\\\", "\\");
                            if (Directory.Exists(lib))
                            {
                                var common = Path.Combine(lib, "steamapps", "common");
                                if (Directory.Exists(common))
                                    candidates.Add(common);
                            }
                        }
                    }
                }
                catch { /* ignore */ }
            }
        }

        // 3) Fallback: typical Steam locations
        void AddIfExists(string path)
        {
            if (Directory.Exists(path)) candidates.Add(path);
        }

        var pfX86 = Environment.GetFolderPath(Environment.SpecialFolder.ProgramFilesX86);
        var pf = Environment.GetFolderPath(Environment.SpecialFolder.ProgramFiles);

        AddIfExists(Path.Combine(pfX86, "Steam", "steamapps", "common"));
        AddIfExists(Path.Combine(pf, "Steam", "steamapps", "common"));

        // 4) Search for "7 Days To Die"
        foreach (var common in candidates.Distinct())
        {
            try
            {
                var gameDir = Path.Combine(common, "7 Days To Die");
                if (!Directory.Exists(gameDir))
                    continue;

                var cfg = Path.Combine(gameDir, "Data", "Config");
                if (Directory.Exists(cfg) && File.Exists(Path.Combine(cfg, "items.xml")))
                    return cfg;
            }
            catch
            {
                // ignore
            }
        }

        return null;
    }

    private static string GetSteamPathFromRegistry()
    {
        try
        {
            using (var key = Registry.CurrentUser.OpenSubKey(@"Software\Valve\Steam"))
            {
                if (key != null)
                {
                    var path = key.GetValue("SteamPath") as string;
                    if (!string.IsNullOrEmpty(path))
                        return path.Replace("/", "\\");
                }
            }
        }
        catch
        {
            // Not on Windows / no Steam
        }

        return null;
    }

    // === Helpers ===

    private static List<int> ParseIntList(string csv)
    {
        var list = new List<int>();
        if (string.IsNullOrWhiteSpace(csv)) return list;

        foreach (var part in csv.Split(','))
        {
            var trimmed = part.Trim();
            if (int.TryParse(trimmed, out int v))
                list.Add(v);
        }
        return list;
    }

    private static List<string> ParseStringList(string csv)
    {
        var list = new List<string>();
        if (string.IsNullOrWhiteSpace(csv)) return list;

        foreach (var part in csv.Split(','))
        {
            var trimmed = part.Trim();
            list.Add(trimmed);
        }
        return list;
    }

    private static bool HasModSlots(string value)
    {
        if (string.IsNullOrWhiteSpace(value)) return false;

        foreach (var part in value.Split(','))
        {
            string t = part.Trim();
            if (int.TryParse(t, out int v) && v > 0)
                return true;
        }
        return false;
    }

    private static string EscapeForXPathName(string name)
    {
        return string.IsNullOrEmpty(name)
            ? name
            : name.Replace("'", "&apos;");
    }
}
